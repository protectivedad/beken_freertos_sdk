#!/usr/bin/env python
#usage:
# python beken_packager_wrapper -i $(CFG_SOC_NAME) -s $(CFG_FLASH_SELECTION_TYPE)

import os
import sys
import json
import shutil
import argparse

out_json_1M = {
    "magic": "RT-Thread",
    "version": "0.1",
    "count": 2,
    "section": [
        {
            "firmware": "bootloader_bk7231n_uart2_v1.0.12.bin",
            "version": "1M.1220",
            "partition": "bootloader",
            "start_addr": "0x00000000",
            "size": "65280"
        },
        {
            "firmware": "../../out/bk7231_bsp.bin",
            "version": "1M.1220",
            "partition": "app",
            "start_addr": "0x00011000",
            "size": "595K"
        }
    ]
}

out_json_2M = {
    "magic": "RT-Thread",
    "version": "0.1",
    "count": 2,
    "section": [
        {
            "firmware": "bootloader_bk7231n_uart2_v1.0.12.bin",
            "version": "2M.1220",
            "partition": "bootloader",
            "start_addr": "0x00000000",
            "size": "65280"
        },
        {
            "firmware": "../../out/bk7231_bsp.bin",
            "version": "2M.1220",
            "partition": "app",
            "start_addr": "0x00011000",
            "size": "1156K"
        }
    ]
}

# 65280 not error with bootloader.bin <= 60K, but 68K will be better
# boot_size = 65280 Bytes = 60K / 32 * 34
#
# 2890K not error with app.bin <= 2720K, but if you want to OTA,
# you should check the OTA partition param:
# OTA_offset >= (0x11000 + 2890K) = 0x2E3800
# OTA_length <= (next_partition_offset - OTA_offset)
# suggest change 2890K => 2516K,
# because of the efficiency of encode method is almost 0.6,
# and APP + OTA will fill with the flash space from 0x11000 to 0x3e0000
out_json_4M = {
    "magic": "RT-Thread",
    "version": "0.1",
    "count": 2,
    "section": [
        {
            "firmware": "bootloader_bk7231n_uart2_v1.0.12.bin",
            "version": "4M.1220",
            "partition": "bootloader",
            "start_addr": "0x00000000",
            "size": "65280"
        },
        {
            "firmware": "../../out/bk7231_bsp.bin",
            "version": "4M.1220",
            "partition": "app",
            "start_addr": "0x00011000",
            "size": "2516K"
        }
    ]
}

out_json_8M = {
    "magic": "RT-Thread",
    "version": "0.1",
    "count": 2,
    "section": [
        {
            "firmware": "bootloader_bk7231n_uart2_v1.0.12.bin",
            "version": "8M.1220",
            "partition": "bootloader",
            "start_addr": "0x00000000",
            "size": "65280"
        },
        {
            "firmware": "../../out/bk7231_bsp.bin",
            "version": "8M.1220",
            "partition": "app",
            "start_addr": "0x00011000",
            "size": "2076K"
        }
    ]
}

chip_index = {
    1: 'bk7231',
    2: 'bk7231u',
    3: 'bk7251',
    4: 'bk7271',
    5: 'bk7231n',
    6: 'bk7236',
    7: 'bk7238',
    8: 'bk7252n'
}

default_info = {
    'bk7231n': {'boot': 'bootloader_bk7231n_uart1_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7231u': {'boot': 'bootloader_bk7231u_uart2_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7231':  {'boot': 'bootloader_bk7231_uart2_v1.0.11.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7251':  {'boot': 'bootloader_bk7251_uart2_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7271':  {'boot': 'bootloader_bk7271_uart2_v1.0.11.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7236':  {'boot': 'bootloader_bk7236_uart2_v1.0.11.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7238':  {'boot': 'bootloader_bk7238_uart1_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7252n': {'boot': 'bootloader_bk7252n_uart1_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
    'bk7253': {'boot': 'bootloader_bk7253_uart2_v1.0.15.bin', 'firmware': '../../out/bk7231_bsp.bin'},
}

# parse commandline arguments
def parse_args():
    description = '''Beken HID Downloader.'''
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('-c', '--chip',
                        default='bk7231u',
                        choices=default_info.keys(),
                        help="chip type, defaults to bk7231u")
    parser.add_argument('-i', '--index', type=int,
                        default=-1,
                        choices=chip_index.keys(),
                        help="chip index: 1: bk7231, 2: bk7231u, 3: bk7251, 4: bk7271, 5: bk7231n, 6:bk7236, 7:bk7238, 8:bk7252n")
    parser.add_argument('-b', '--boot',
                        help='specify boot file')
    parser.add_argument('-f', '--firmware',
                        help='specify firmware file')
    parser.add_argument('-s', '--size',
                        default='0x200000',
                        help='specify flash size')
    args = parser.parse_args()

    return args

args = parse_args()
chip = chip_index[args.index] if args.index>=0 else args.chip
bootloader_str = args.boot if args.boot else default_info[chip]['boot']
firmware_str = args.firmware if args.firmware else default_info[chip]['firmware']

#convert hex string to integer
if args.size.startswith("0x"):
    args.size = int(args.size.replace("0x", ""),16)
else:
    args.size = int(args.size)
#select json with flash size
boot_json = " partition.json"
if args.size >= 0x800000:
    out_json = out_json_8M
elif args.size >= 0x400000:
    out_json = out_json_4M
elif args.size >= 0x200000:
    out_json = out_json_2M
elif args.size >= 0x100000:
    out_json = out_json_1M
else:
    out_json = out_json_2M
    boot_json = "partition_2M.json"

if sys.platform == 'cygwin':
    cmd_str = "../rt_partition_tool/rt_partition_tool_cli.exe " + bootloader_str +  boot_json
else:
    cmd_str = "../rt_partition_tool/rt_partition_tool_cli " + bootloader_str + boot_json
#print(cmd_str)
os.system(cmd_str)

out_path = "tmp.json"
full_image_old = "all_" + out_json["section"][0]["version"] + ".bin"
uart_image_old = "bk7231_bsp_uart_" + out_json["section"][0]["version"] + ".bin"
if args.index >= 0:
    full_image_new = chip_index[args.index] + "_" + out_json["section"][0]["version"] + ".bin"
    uart_image_new = chip_index[args.index] + "_bsp_uart_" + out_json["section"][0]["version"] + ".bin"
else:
    full_image_new = chip + "_" + out_json["section"][0]["version"] + ".bin"
    uart_image_new = chip + "_bsp_uart_" + out_json["section"][0]["version"] + ".bin"

# set right size for boot and app
with open("packager.json", 'r') as file:
    packager_json = json.load(file)
    if((packager_json["section"][0]["name"]) == "bootloader") :
        out_json["section"][0]["size"] = packager_json["section"][0]["size"]
    if((packager_json["section"][1]["name"]) == "app") :
        out_json["section"][1]["size"] = packager_json["section"][1]["size"]

out_json["section"][0]["firmware"] = bootloader_str
out_json["section"][1]["firmware"] = firmware_str

# cmd for ota packager rbl
if("bin" in firmware_str) :
    firmware_rbl = firmware_str.replace(".bin", ".rbl")
else:
    firmware_rbl = firmware_str + ".rbl"
if sys.platform == 'cygwin':
    ota_pack_cmd = "../rtt_ota/rt_ota_packaging_tool_cli.exe -f " + firmware_str
else:
    ota_pack_cmd = "../rtt_ota/rt_ota_packaging_tool_cli-x86 -f " + firmware_str
ota_pack_cmd = ota_pack_cmd + " -v " + out_json["section"][0]["version"]
ota_pack_cmd = ota_pack_cmd + " -o " + firmware_rbl
ota_pack_cmd = ota_pack_cmd + " -p " + out_json["section"][1]["partition"]
ota_pack_cmd = ota_pack_cmd + " -c lzma -s aes -k 0123456789ABCDEF0123456789ABCDEF -i 0123456789ABCDEF"

out_json = json.dumps(out_json, sort_keys=True, indent=4)
#print(out_json)

with open(str(out_path), "w") as f:
    f.write(out_json)

# check firmware size, should less than app size
firmware_size = os.path.getsize(firmware_str)
app_size = 0
with open("partition.json", 'r') as file:
    partition_json = json.load(file)
    if( partition_json["part_table"][1]["name"] == "app") :
        app_size = int(partition_json["part_table"][1]["len"])
        #print(firmware_size, app_size)
        if(firmware_size > app_size) :
            raise ValueError("\033[31m firmware size:{} larger than app size:{}\033[0m".format(firmware_size, app_size))

if sys.platform == 'cygwin':
    os.system("./beken_packager.exe {}".format(out_path))
else:
    os.system("./beken_packager {}".format(out_path))
#copy all_2M.1220.bin as default for tools/script/build_include.sh
shutil.copy(full_image_old, "../../out/" + full_image_old)
shutil.move(full_image_old, "../../out/" + full_image_new)
shutil.move(uart_image_old, "../../out/" + uart_image_new)
shutil.copy(bootloader_str, "../../out/" + bootloader_str)

# excute cmd for ota packager
#print(ota_pack_cmd)
os.system(ota_pack_cmd)

# check rbl size, should less than ota size
rbl_size = os.path.getsize(firmware_rbl)
ota_size = 0
with open("partition.json", 'r') as file:
    partition_json = json.load(file)
    if( partition_json["part_table"][2]["name"] == "download") :
        ota_size = int(partition_json["part_table"][2]["len"])
        #print(rbl_size, ota_size)
        if(rbl_size > ota_size) :
            raise ValueError("\033[31m rbl size:{} larger than ota size:{}\033[0m".format(rbl_size, ota_size))

os.remove(out_path)
os.remove("partition.json")
os.remove("packager.json")
